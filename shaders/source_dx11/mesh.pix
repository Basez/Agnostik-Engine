Texture2D diffuseTexture : register(t0);
Texture2D normalTexture : register(t1);
Texture2D specularTexture : register(t2);

SamplerState SampleType : register(s0);

struct InputData
{
	float2 uv : TEXCOORD0;
	float4 normalWS : TEXCOORD1;
	float4 positionWS : TEXCOORD2;
	float4 tangentWS : TEXCOORD3;
	float4 biTangentWS : TEXCOORD4;
};

cbuffer LightSettings : register(b0)
{
	float4 lightDirection; // Light's direction in world space.
	float4 lightColor; // Light's diffuse and specular contribution.
	float4 lightAmbient; // Global ambient contribution.
	float4 eyePosition;
}

cbuffer MaterialProperties : register(b1)
{
	float materialTransparency;
	float3 materialDiffuseColor;
	//-- 16bytes --//

	float3 materialAmbientColor;
	float materialSpecularPower;
	//-- 16bytes --//

	bool materialHasDiffuse;
	bool materialHasNormalMap;
	bool materialHasSpecularMap;
	//float3 materialSpecularColor;
	//-- 16bytes --//
}

float4 CalculateDiffuse(float3 a_normal, float4 a_lightColor, float3 a_lightDirection)
{
	float nDotL = max(dot(a_normal, a_lightDirection), 0);
	float4 diffuse = nDotL * a_lightColor * float4(materialDiffuseColor, 1.0f);
	return saturate(diffuse);
}

float4 CalculateSpecular(float3 a_normal, float4 a_lightColor, float3 a_lightDirection, float3 a_positionWS, float a_specularIntensity)
{
	float3 directionToEye = normalize(eyePosition.xyz - a_positionWS.xyz);
	float4 materialSpecularColor = float4(1, 1, 1, 1); // TODO!!!!!!!!!

	// Phong lighting.
	float3 R = normalize(reflect(-a_lightDirection, a_normal));
	float RdotV = max(0, dot(R, directionToEye));
 
	// Blinn-Phong lighting
	//float3 H = normalize(-a_lightDirection + directionToEye);
	//float NdotH = max(0, dot(a_normal, H));
 
	float4 specular = pow(RdotV, materialSpecularPower) * a_lightColor * materialSpecularColor;

	return saturate(specular * a_specularIntensity);
}

float CalculateSpecularIntensity(InputData IN)
{
	float specularIntensity = 1.0f;

	if (materialHasSpecularMap) specularIntensity = specularTexture.Sample(SampleType, IN.uv).r + specularTexture.Sample(SampleType, IN.uv).g + specularTexture.Sample(SampleType, IN.uv).b;

	return specularIntensity;
}

float3 CalculateNormal(InputData IN)
{
	if (materialHasNormalMap)
	{
		// get normal from normalmap
		float4 texNormal = normalTexture.Sample(SampleType, IN.uv);
	
		// move from 0to1 --> -1 to 1
		texNormal = (texNormal * 2.0f) - 1.0f;

		float3x3 tangentBinormalNormalMatrix = float3x3( normalize( IN.tangentWS ).xyz, normalize( IN.biTangentWS ).xyz, normalize( IN.normalWS ).xyz );
		float3 bumpedNormal = mul( normalize( texNormal.xyz ), tangentBinormalNormalMatrix ); 

		return bumpedNormal;
	}
	else
	{
		return normalize( IN.normalWS ).xyz;
	}
}

float4 Main(InputData IN) : SV_TARGET
{
	float4 textureColor = float4(0,0,0,0);
	if (materialHasDiffuse) textureColor = diffuseTexture.Sample(SampleType, IN.uv);
	
	float specularIntensity = CalculateSpecularIntensity(IN);
	float3 normal = CalculateNormal(IN);
	float3 lightDirectionNorm = normalize(lightDirection).xyz;

	// calculate diffuse and spec
	float4 diffuse = float4(0,0,0,0);
	float4 specular = float4(0,0,0,0);

	if (materialHasDiffuse) diffuse = CalculateDiffuse(normal, lightColor, lightDirectionNorm);
	specular = CalculateSpecular(normal, lightColor, lightDirectionNorm, IN.positionWS.xyz, specularIntensity);

	// apply ambients and calculate final color
	float4 lighting = diffuse + specular + float4(materialAmbientColor, 0.0f) + lightAmbient;
	float4 finalColor = lighting * textureColor;

	return finalColor;
}